- диспетчеры событий
- поддержка .jpg
- поддержка .tga
- графический 3d движек
- физический 3d движек
- поддержка .3ds
- редактор коллекций (как проект mpp наверное делать не стоит, но он на нем д/б основан и лежать в tools)
- импортирование ptr, dobject, ptr_list
- класс large_array или аллокаторы (в общем придумать что-то по унификации работы с памятью)
- сделать each_ptr(const point<> &from, point<> &to, point<> &step) и возможно each_ptr_xy, each_ptr_yx с темиже параметрами
- сделать log_viewer - для просмотра логов и новый интерфейс для логов и консоли. 
	[логи можно показывать ввиде списка соообщений, а в другом окне подсвечивать строку лога в нужном файле]
- разделить состояния и анмации (т.е. у объекта м/б только одна активная анимации и на нее передается цикл)
	при этом должна-ли анимация давать событие что она закончена? да, пожалуй. еще анимация может проигрываться
	в обоих направлениях
- состояния объекта никак не привязанны к анимации. т.е. при перемещении влево состояние move_left, а анимация м/б
	move_left, move_on_mud_left, move_on_ladder_left итп. и кстати при падении состояние тоже д/б move_left, а
	активная анимация - drop
	вопрос должны-ли состояния быть объектами или числами?
	т.е. состояние объекта, его физические параметры и анимация 3 вещи слабо друг с другом связанные, но
	зависящие от врешних соббытий. причем от события может изменится как только одно из них так и все 3.
	в данный момент физика независима. осталось разделить состояния и анимации.
	параметры анимации должны задаваться извне (в anim.xml. длительность, битмап, строка, звук начала анимации и звук
	конца анимации)
	для начала сейчас очень просто сделать загрузку анимаций из xml.
	- но для разделения анимации и состояния нужно подумать. проблемы возникают с тамерами. т.е. при остановке
	анимации. эти проблемы остануться. а главная проблема - учет при смене состояния и пуске/останове анимации 
	взаимосвязей.
	да, еще имеет смысл постепенный перенос в xml описания загружаемых ресурсов - т.е.
	в для этого дергать cache - а там они все по именам лежат. ресурсы где нужно создадут
	указатели на ресурсы и положат их в кэш, т.е. нужно стараться сделать работу с ресурсами через кэш.
	тогда в xml можно указывать и параметры качества для ресурсов
	таким образом я избавлюсь от явных строк кода при загрузке коллекций - т.е. коллекция будет грузить ресурсы
	исходя из того что написано в xml, а потом уже по имени ресурса (?) его м/б получить как указатель.
	т.е. явных ресурсов в коллекциях должно поубавится - и они будет во внешнем xml.

    все еще большой вопрос - что делать с анимациями и состояниями? получается таже структура что и сейчас.
    ее нужно как-то переделать. можно считать что все сотояния объекта анимированны и остановке не подлежат..
    это снимет часть проблем, т.е. то то нельзя остановить состояние, и при том к-л состояние у активного объкта всегда
    есть че-то стоит т.е. детали получится упрятать - расшифровку что из себя представляет состояние делаем в xml,
    реализацию сводим к одному интерфейсу, а объект их только переключает между собой. что уже хорошо. т.к. в 
    программе не нужно выбирать какое состояние создавать в конструкторе.
	в принципе в xml можно вынести запрещенные состояния - из которых переключаться нельзя. т.е. описать побольше состояний.
	программа будет пытаться их выставлять. а некий менеджер состояний объекта будет следить что можно а что нет.
	т.е. event(key_left)
	if (set_state(move_left))
		switch (ground_type)
		{
			
		}
	да, еще полезно хранить указатель на предыдущее состояние объекта - (заморозка, продолжения хотьбы, малоли что 
	понадобится?)
	но всеравно, как лучше разруливать неск. паралельных состояний?
	хотьба по разным повехностям
	хотьба+падение
	заморозка+падение
	т.е. падение по мимо физ. падения это еще и состояние, а во время падения м/б и другое состояние.
	в общем из-за нехватки этих состояних и получается коломбур.
	может сделать очередь состояний? т.е. хранить неск. состояний объекта а потом тестить очередь на наличие в ней к-л 
	состояния
- сделать поддержку хэшей
	switch (b->hash())
	{
		case HASH(top10):

		case HASH(options):
	}
