/* naPalm Runner
  Copyright (C) 2006
  Author: Alexander Semenov <acmain@gmail.com>
*/
//================================================================================
// обработка событий - самый высокоуровневый и ресурсоемкий процесс
// должен быть максимально использован в приложениях, но им нужно очень осторожно 
// пользоваться в mpp и не использовать в интерфейсах под платформы вообще
// вообще говоря при малых частотах цикла кол-во событий не влияет на скорость,
// а при больших - это тем более критично, т.к. куча посторонних вычислений в цикле
// все убьет
//================================================================================
#ifndef _MPP_EVENT_HANDLER_
#define	_MPP_EVENT_HANDLER_

#include "list.h"
#include "tools.h"

namespace mpp
{
//	namespace events
//	{
		template <class T>
		class dispatcher;
		/*
		что выбрать? базовый класс для событий, или так как сейчас?
		во первых сейчас где-то ошибка.. - нужно чтобы dispatcher
		работал с event(ev), event(ev, source). при чем передача шла-бы
		через event(ev, source), а event() - дополнительный метод
		pass event лучше оставить - этот фильтр поможет фильтровать сообщения 
		для потомков в том числе.. но нужны покачто можно все перевести на 
		event(ev, source) - 
		*/

		//================================================================================
		//	обработчик события
		//================================================================================
		template <class T>
		class handler
		{
		protected:
			dispatcher<T>	*external;	// внешний источник события
		
		public:
			//------------------------------------------------------------
			inline	handler(dispatcher<T> *ext=NULL)
				:external		(ext)
			{
				if (external)
					external->add_internal(this);
			}

			//------------------------------------------------------------
			virtual ~handler()
			{
				if (external)
					external->remove_internal(this);
			}

			//-------------------------------------------------------------------
			// source - нужен для отсечения источника соббытия
			virtual	void event(T *ev, void *source)=0;

			//-------------------------------------------------------------------
			// фильтрует входяшие события
			virtual bool pass_event(T *ev)
			{
				return true;
			}

			//--------------------------------------------------------
			// используется деструктором внешнего класса, чтоб потом этот класс не пытался в него влезть
			inline void clean_external()
			{
				external=NULL;
			}
		};



		//===============================================================================
		// передает сообшение "вниз" всем классам по условию
		//===============================================================================
		template <class T>
		class dispatcher : public handler<T>
		{
		public:
			//------------------------------------------------------------
			inline	dispatcher(dispatcher<T> *ext=NULL)
				:handler<T>(ext)
			{
			}

			//--------------------------------------------------------
			~dispatcher()
			{
				while (handler<T> *h=internals.each())
					h->clean_external();
			}	

			//--------------------------------------------------------
			void event(T *ev, void *source)
			{
				if (pass_event(ev))
					while (handler<T> *h=internals.each())
//						if (h!=source && h->pass_event(ev))
							h->event(ev, source);
			}

			//--------------------------------------------------------
			inline	void add_internal(handler<T> *h)
			{
				internals.push_back(h);
			}


			//--------------------------------------------------------
			inline	void remove_internal(handler<T> *h)
			{
				internals.remove(h);
			}

		protected:
			list<handler<T>*>	internals;	// внутренние обработчики событий
		};


		//=======================================================================
		// класс предназначенный для автоматического связывания со статическим классом
		//=======================================================================
		template <class T, class externT>
		class static_source : public T
		{
		public:
			inline	static_source()
				:T(&externT::get())
			{
			}
		};



		//=======================================================
		template<class T>
		inline void send(T *ev, handler<T> *dst, void *source)
		{
			dst->event(ev, source);
		}

//	}
}

#endif