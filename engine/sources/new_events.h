/* naPalm Runner
  Copyright (C) 2006
  Author: Alexander Semenov <acmain@gmail.com>
*/
#ifndef _MPP_NEW_EVENTS_H_
#define _MPP_NEW_EVENTS_H_

/*
по поводу соббытий:
нужна другая организация. не иерархическая. т.е. объект является слушателем события, при этом имеет все экземпляры
событий вложенные в себя, а они уже дергают его обработчик с указанием на себя.
*/

namespace	new_events
{
	class	handler;
	class	listener;

	//источник события
	class	message
	{
		bool send()	// false если никто не обработал
		{
			bool	result=false;
			while (listener *l=listeners.each())
			{
				if (l->event(this))
					result=true;
				l->event(NULL);
			}	
			return result;
		}
        
    private:
    	list<listener*>	listeners;
	};
	
	// слушатель имеет только методы необходимые для возращении инфы о произошедшем событии или должен просто
	// давать указатель на источник события? в принципе, при ситьной типизации задача listener может ограничится
	// только переводом сообщения до handler, а в message можно уже закладывать нужную инфу. он ее и вернет
	// впринципе если сюда "до кучи" воткнуть список фильтро, то наверное не очень страшно. т.к. гибкость повысится,
	// а этот класс станет более функциональным
	class listener
	{
		bool event(message *_s);	// при этом во избежании циклических эвентов, message сначала подает сам event, а потом NULL
		{
			s=_s;
			if (s)
			{
				while (filter *f=filters.each())
					if (filters.find(!f->filter_event(s)))
						return false;
				return h->event(this);
			}
			return false;
		}

		void push_filter(filter *f);
		void remove_filter(filter *f);

	private:
		handler	*h; // обработчик события
		message	*s;	// источник события. при возникновении события указатель на message передается по всем
					// слушателям. а они, используя приведение типа могут передать нужную информацию в hander
					// при этом handler может абсолютно не иметь ни каких явных связей с другими классами,
					// все это можно реализовать в классах message и listener
		list<filter*>	filters;
	};

	// тогда для удобства можно использовать wraper
	// который предсталяется указателем на message. т.е. оч.удобно и логично
	template<class T>
	class event : public listener
	{
		T *operator->() { return (T*)message; }
		operator *T()  { return (T*)message; }
	};


	// может еще вознинуть проблема обработки связей - т.е. множество message передает сообщения множеству listener
	// как удалять listener, чтобы он удалялся из списка message? можно конечно сделать рассылку сообщения destroy
	// и тогда пробегаясь по всему списку источника можно выкинуть listener по совпадению указателей. правда это тормозно и
	// не оч. красиво

	class handler
	{
		bool event(listener *ev); //если false, передаать на обработку связанным слушателям
	};

	// еще можно делать совмещенный класс
	// но тут нужно как-то следить за типами, инче он начент все соббытия пересылать, из чего следует неверное приведение типов
	class reciver : public handler : public listener
	{
		bool handle(listener *ev)
		{
			return h->handle(ev);
		}
	};

	// и еще нужно подумать про класс-фильтр сообщений (чтобы его м/б внедрить между listener и handler.
	// т.е. внедрить в listener скорее всего или один, или список фильтров и если фильтр будет возвращать false,
	// то не передавать сообщение на обработку handler) при этом фильтр исключительно булевская операция.
	// т.к. если потребуется просто получить тоже сообщение что и этот listener, то нужно передусмотреть механизм
	// подключения его к соответствующим message-ам. а фильтр - для регулирования поведения стороннего объекта.
    // возникает еще такой вопрос - должны-ли message и listener -ы быть открытыми членами классов?
	// по OOП это зло, но система вся строящаяся на них, пожалуй должна их иметь открытыми. для того
	// чтобы на них м/б просто ссылаться по имени. без лишнего кода
	class filter
	{
		bool filter_event(listener *ev)
		{
		}
	};
	/*
	!! все будет очень красиво, если поставить связь: 1message<->1listener. между ними однозначное
	соответствие. а если потребуется массовая рассылка соообщений+фильтрация, то завести новый класс
	dispetcher который будет наследоваться от message и listener, содержать списки обоих + список фильтров.
	таким образом рассылка сама очень проста, и ее базовые классы тоже. а нужная гибкость будет в диспетчере.
	при удалении message или listener или filter будут просто об этом сообщать диспетчеру и он их уберет.
	если нужно фильтровать меньший диапазон сообщений, можно созжать диспетчер второго уровня :)
	*/
	class dispatcher : public message : public listener
	{
		list<message>
		list<filter>
		list<listener>

	}

	// т.к. есть статические классы, то по умолчанию многие эвенты можно считать если message=NULL, то берется 
	// соответсвующий статический-message; а когда нужно, указывать явный класс-источник event-a
}


// handler устанавливает первоночальный источник сообщений, но его поведение можно регулировать со стороны.
// он становится автоматом имеющим внутреннее состояние и реагирующим только на события
class some : public new_events::hander
{
public:	// events
	event<mouse>		mouse;
	event<key_up, key_down, key_char>	keyboard;
    event<collision>	collision;
    event<cycle>		cycle;
    event<timer>		timer;

    event<creature_state>	move,
    						drop;

	bool event(new_events::listener *ev)
	{
		if (ev==&mouse)
		{
			mouse->point();
		}
		else if (ev==&keyboard)
		{			
			keyboard->key()
			keyboard->pressed(key)
		}
		else if (ev==&collision)
		{
			collision->force()
			collision->objects()
			collision->vector()
		}

	}
};


// а реализация message м/б такой:
// плюс - сам источник ничего не знает о том кто его отправляет и кому. он только получает данные и отдает их
// по запросу. все. :)
class mouse : protected new_events::message
{
public:
	bool send(const point &p)
	{
		pos=p;
		return send();
	}

	const point &point() const { return pos; }

private:
	point pos;
};


/*
	еще одна тема: должен-ли message знать какие слушатели у него есть? не черезчур ли это?
	возможно стоит создавать диспетчер, содержащий список слушателей и список фильтров,
	а события в него сможет отсылать абсолютно любой класс? тогда этот самый любой класс должен знать 
	диспетчер, в который он отсылает сообщение, впрочем это наверное не проблема. т.к. диспетчеры можно
	сделать открытыми методами статических классов. например в application имеет смысл сделать диспетчеры
	мыши, клавы и пр.
	т.е приходим к нескольким моментам:
	1. класс message - локальный класс - контейнер. создаваемый в стеке ипредназначенный 
		для удобства абстрактной передачи сообщения
	2. класс event - внутренний класс, принимающий сообщения и генерящий событие. 
		он также указатель на полученный event
	3. класс handler - базовый класс для обработчика событий. содержит только одну ф-ию event - пришло событие
	
	это основные положения нового обработчика событий. т.е. со стороны пользователя детали скрыты и все рапределенно
	и довольно удобно (в принципе можно пойти дальше - если классы message сделать виртуальными, то модули будут очень
	слабо между собой связанны)

	теперь о транспортировке нужен класс который будет отвечать за прием и доставку сообщений.
	возможно даже семейство классов. reciver, filter, sorter, switcher (передатчик, фильтр, сортировщик и избиратель)

	как он будет связан с объектами? определенно у него д/б массив слушателей. при этом он сам д/б слушателем.
	а у слушателя должен быть указатель на него (чтобы удалять себя из списка)
	т.к. message является временным объектом, то он не знает откуда пришло сообщение, но сам message может
	в себе нести эту информацию при надобности
	
	т.е. класс который хочет передать сообщение должен создать объект производного класса от message и передать его
	нужному классу диспетчеру.. правда здеть теряется контроль типов.. хотелось-бы чтобы небыло случайных приведений.
	с другой стороны, класс содержащий диспетчер просто не знает какими типами он оперрирует и соответсвенно меньше завязок
	в коде...

	т.е. вариант 1: используеся приведение типа на финальном шаге. но модули могут бытьдостаточно разрозненны.
	вариант 2: диспетчер - это шаблон и хранит указатели на event<нужный класс> - надежно, но требует побликации класса
	сообщения.. впрочем эта публикация в дюбом случае нужна..
	
	т.е. вариант 2 не так плох, но он не позволит передавать в качестве слушателя event<производный класс>...
	правда если шаблоном будет listener, то производный класс прокатит, но прокатит-ли handler?
	в том плане что ему-то прийдется либо наследоваться от кучи шаблонов как сейчас, либо иметь одну ф-ию
	с праметром void *по которой можно будет передавать значение..

	чем это заканчивается? тем что есть класс, производный от к-л типа handler и при этом ему передается в
	качстве параметра например указатель на событие... по которому он все получает. тоже самое что и было?
	1. есть параметр-структура
	2. есть класс-обработчик
	3. класс регистрируется. у вышестоящего

	пожалуй отличие в транспортировке - раньше использовался текущий класс для этого, а теперь совершенно
	отдельная сущность, которую можно получить по имени.

	не будет базового класса-посылателя сообщения. посылать сообщение сможет каждый класс
	по поводу базового класса на сообщения как сейчас... можно конечно сделать биспетчер базовым а не
    внутренним классом... чем это только черевато? опять -таки ему нужно указывать источник сообщения,
    и можно использовать тотже механизм что и сейчас. разница в том что вместо up_sender/down_sender
    он будет отправлять сообщение сразу обработчикам, т.е. у него по умолчанию много входов. и много выходов.
    если входов много а выход один - лучше сразу дергать метод объекта. таким образом рассылка сообщений 
    эффективна только при нескольких выходах. 
    теперь не нужно будет регестрироватся в том что ты источник сообщения.. но как быть с пересылкой..
    т.е. в конструктор всеравно передается указатель на диспетчер, только теперь диспетчеры вместно неудобной
    рассылки вверх и вниз смогут фильтровать и упорядочить рассылку сообщений.
    а еще можно сделать диспетчер-триггер (открыт/закрыт) без фильтра, для простого блокирования пересылки сообщений..
    т.е. наверное всетаки нового глобально обработчика событий не будет, но старая структура будет несколько перекроена.


    а вообще стоит подумать о той структуре что описана сначала. возможно она имеет смысл

    всетаки нет, старый интерфейс с различными диспетчерами выглядит перспективнее и нуждается в меньших
    переделках. т.е. в ближайшее время следует определить типы диспетчеров и их работу.
    если их закодить то перевод старой системы на новую не д/б достаточно болезненен.

    главное отличие - в подходе. изначально механизм был рассчитан на перегон сообщений по иерархии, т.е.
    он ее дублировал и считалось что каждый класс иерархии должен учавствовать в пересылке.
    теперь будет сетка диспетчеров, без иерархии, с перекресными связями. этот механизм
    д/б более гибок. темболее новые ф-ии фильтрации позволят реководить поведением диспетчеров из сторонних классов
    иерархия какая-то всетаки будет. на уровне одного сообщения (чтоб назад не возвращалось, но на уровне всех
    связей должна быть достаточно плоская сетка)

    вопрос еще в том как организовавать диспетчеры:
    1. как сейчас - базовым классом - пожалуй не оч красиво.. и не оч. удобно. зато можно указывать сам класс как диспетчер
    2. встоенным полем - поле д/б открытым. на элемент тогда ссылаться неск. длиннее, но возможно код будет стройнее
    3. встроенным указателем - тоже что и выше, но диспетчер м/б подменить (например в потомке.. для чего это м/б нужно пока не знаю)
    	в принципе, поведение диспетчера должно определятся только фильтрами. тогда надобность в его перегрузке отпадет
    4. статическим объектом
    	оч. просто узнать куда слать сообщение и оч. просто прявязать себя к такому диспетичеру, но
    	статические объеты -зло, и полученная модель небудет гибкой
    5 статическим указателем
    	тоже что 4, но диспетчеры м/б подменять или удалять 
*/

#endif // _MPP_NEW_EVENTS_H_
